// Pong.cpp
#include "stdafx.h"
#include "cvui.h"
#include <opencv2/opencv.hpp>

#include "Pong.h"
#include "CControl.h"
#include <conio.h>
#include <chrono>
#include <thread>

#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;

Pong::Pong(int comPort)
{
   resx = 1000; //1000
   resy = 800; //800
   CBase4618::canvas = cv::Mat::zeros(resy, resx, CV_8UC3);
   CBase4618::canvas = cv::Scalar(0, 0, 0);
   CBase4618::exitButton = false;

   // Analog Start State
   int ypos;
   ydata = control.get_analog(26, ypos);
   ydata = (1 - (ydata / 100));
   ydata2 = 0;
   
   // Max paddle velocity
   maxPaddleVelocity = 60;

   // Getting Starting Button State
   control.get_data(0, 33, stateBefore1);
   control.get_data(0, 32, stateBefore2);

   // Turn off LED
   control.set_data(0, 37, 0);
   control.set_data(0, 38, 0);
   control.set_data(0, 39, 0);

   // Resetting ball and paddle values
   reset();
   ///////////////////////////////////////CHAT
   // Define the decision tree

   ////////////////////////////////////////CHAT
}

Pong::~Pong() {}

void Pong::draw(cv::Mat &canvas)
{
   // MENU FRAME and TEXT
   // Button menu background 
   cv::rectangle(canvas, cv::Rect(10, 10, 220, 210), cv::Scalar(70, 70, 70), -1);

   // BUTTONS
   // Reset Button
   if(cvui::button(canvas, 15, 180, 100, 30, "Reset"))
   {
      // Resetting the Canvis
      reset();
   }

   // Exit button
   if(cvui::button(canvas, 125, 180, 100, 30, "Exit"))
   {
      exit(0);
   }

   // TRACKBAR
   // Ball size
   cvui::text(canvas, 80, 60, "Ball Size", 0.5, 0xFFFFFF);
   cvui::trackbar(canvas, 15, 60, 200, &ballSize, (int)5, (int)100);

   // Ball speed
   cvui::text(canvas, 75, 120, "Ball Speed", 0.5, 0xFFFFFF);
   cvui::trackbar(canvas, 15, 120, 200, &ballSpeed, (int)100, (int)400);

   // LETTERS AND TEXT
   // Title background
   cv::rectangle(canvas, cv::Rect(10, 10, 220, 30), cv::Scalar(50, 50, 50), -1);

   // Pong title
   cvui::text(canvas, 15, 15, "Pong", 0.8, 0xFFFFFF);

   // FPS
   cvui::printf(canvas, 120, 18, 0.6, 0xFFFFFF, "FPS: %.2f", (fpsAverage));
}

void Pong::update()
{
   // Start timer
   auto startTime = std::chrono::system_clock::now();
   auto endTime = std::chrono::system_clock::now() + std::chrono::milliseconds(27);

   // Clear canvas
   canvas = cv::Scalar(0, 0, 0);

   // Paddle Controls
   int posy;
   float ydata;
   // Player paddle
   ydata = control.get_analog(26, posy);
   if(ydata >= 60.0)
   {
      ydata = maxPaddleVelocity * (-(ydata-50) / 100);
   }
   else if(ydata <= 40)
   {
      ydata = maxPaddleVelocity * (((100 - ydata)-50) / 100);
   }
   else ydata = 0.0;

   std::cout << ydata << "\r";

   paddle1Y += ydata;

   // Opponent paddle
   /*
   if(((paddle2Y + paddleHeight/2) >= ballPosY))
   {
      if(abs((paddle2Y + paddleHeight/2) - ballPosY) > 30)
      {
         ydata2 -= 3.0/2.0;
      }
      else
      {
         ydata2 -= 1;
      }
   }
   else if((paddle2Y + paddleHeight/2) <= ballPosY)
   {
      if(abs((paddle2Y + paddleHeight / 2) - ballPosY) > 30)
      {
         ydata2 += 3.0/2.0;
      }
      else
      {
         ydata2 += 1;
      }
   }
   else
   {
      ydata2 = 0;
   }
   */
   ///////////////////////////////CHATGPT
   int distance = abs((paddle2Y + paddleHeight / 2) - ballPosY);
   if(distance > 30)
   {
      ydata2 += ((paddle2Y + paddleHeight / 2) > ballPosY) ? -3 / 2 : 3 / 2;
   }
   else
   {
      // Move the paddle slower if the ball is close
      ydata2 += ((paddle2Y + paddleHeight / 2) > ballPosY) ? -1 : 1;
   }

   // Clamp the paddle position within the game area
   // ydata2 = std::max(paddleHeight / 2, std::min(ydata2, gameHeight - paddleHeight / 2));

   ///////////////////////////////CHATGPT
   paddle2Y += ydata2;

   // Paddle boundaries
   if(paddle1Y < 0)
   {
      paddle1Y = 0;
   }
   else if(paddle1Y > (resy - paddleHeight))
   {
      paddle1Y = resy - paddleHeight;
   }
   if(paddle2Y < 0)
   {
      paddle2Y = 0;
   }
   else if(paddle1Y > (resy - paddleHeight))
   {
      paddle1Y = resy - paddleHeight;
   }

   // Moving the Ball
   ballPosX += ballVelocityX * ballSpeed / 30;
   ballPosY += ballVelocityY * ballSpeed / 30;

   // Bounce the ball off the walls
   if(ballPosX <= ballSize || ballPosX >= canvas.cols - ballSize)
   {
      ballVelocityX = -ballVelocityX;
   }
   if(ballPosY <= ballSize || ballPosY >= canvas.rows - ballSize)
   {
      ballVelocityY = -ballVelocityY;
   }

   // Bounce off the Paddles
   // Paddle 1
   if(((paddle1X + paddleWidth) >= (ballPosX - ballSize)) && (paddle1Y <= ballPosY) && ((paddle1Y + paddleHeight) >= ballPosY))
   {
      ballVelocityX = -ballVelocityX;
      ballVelocityY += ydata/15;
   }
   // Paddle 2
   if(((paddle2X - paddleWidth) <= (ballPosX + ballSize)) && (paddle2Y <= ballPosY) && ((paddle2Y + paddleHeight) >= ballPosY))
   {
      ballVelocityX = -ballVelocityX;
      ballVelocityY += rand() % 5 - 2;
   }


   // Drawing the objects
   cv::rectangle(CBase4618::canvas, cv::Rect(paddle1X, paddle1Y, paddleWidth, paddleHeight), cv::Scalar(255, 255, 255), -1);
   cv::rectangle(CBase4618::canvas, cv::Rect(paddle2X - paddleWidth, paddle2Y, paddleWidth, paddleHeight), cv::Scalar(255, 255, 255), -1);
   
   cv::circle(CBase4618::canvas, cv::Point(ballPosX, ballPosY), ballSize, cv::Scalar(255, 255, 255), -1);

   // Clearing Canvas with Button 2
   if(control.get_button(32))
   {
      // Default ball values
      reset();
   }

   // Wait function
   std::this_thread::sleep_until(endTime);

   // FPS
   auto timeFinished = std::chrono::system_clock::now();
   std::chrono::duration<double> elapsed_seconds = timeFinished - startTime;
   fps = 1.0 / elapsed_seconds.count();

   // Average FPS
   const int n = 10;
   static double fpsValues[n] = {};

   for(int i = 0; i < n - 1; i++)
   {
      fpsValues[i] = fpsValues[i + 1];
   }
   fpsValues[n - 1] = fps;

   // Calculate the rolling average of the fps values
   double fps_sum = 0;
   for(int i = 0; i < n; i++)
   {
      fps_sum += fpsValues[i];
   }
   fpsAverage = fps_sum / n;
}

void Pong::reset()
{
   canvas = cv::Scalar(0, 0, 0);

   // Default ball values
   ballSize = 5;
   ballSpeed = 100;

   ballPosX = resx / 2;
   ballPosY = resy / 2;

   // Radom Values
   

   ballVelocityX = ballSpeed / 30.0;
   ballVelocityY = 0;

   // Default paddle values
   paddleWidth = 10;
   paddleHeight = 100;

   paddle1X = 80;
   paddle1Y = (resy / 2) - (paddleHeight / 2);

   paddle2X = resx - paddle1X;
   paddle2Y = (resy / 2) - (paddleHeight / 2);
}